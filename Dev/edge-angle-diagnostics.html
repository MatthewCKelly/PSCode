<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>SOE Edge â€“ ANGLE/WebGL diagnostics (final corrected)</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  :root { color-scheme: dark; }
  html,body { height:100%; margin:0; background:#0f172a; color:#e2e8f0;
    font-family: system-ui, Segoe UI, Arial, sans-serif; }
  #wrap { display:grid; grid-template-columns: 1fr 400px; gap:16px; height:100%; transition: grid-template-columns 0.3s ease; }
  #wrap.panel-collapsed { grid-template-columns: 1fr 0px; gap:0; }
  #panel { padding:16px; border-left:1px solid #334155; overflow:auto; transition: all 0.3s ease; }
  #panel.collapsed { opacity: 0; padding: 0; width: 0; overflow: hidden; }
  #togglePanel { position:absolute; right:16px; top:16px; z-index:10; transition: right 0.3s ease; }
  #wrap.panel-collapsed #togglePanel { right:0; }
  #workerSection { display:none; margin-top:12px; }
  #workerSection.visible { display:block; }
  h1,h2 { margin:0 0 8px; }
  p,li { line-height:1.35; }
  button { padding:8px 12px; margin:4px 4px 8px 0; border:1px solid #334155;
    background:#1f2937; color:#e2e8f0; cursor:pointer; border-radius:6px; }
  button:disabled { opacity:.6; cursor:not-allowed; }
  .row { display:flex; flex-wrap:wrap; gap:8px; margin:4px 0 8px; }
  .ok { color:#22c55e; } .warn { color:#f59e0b; } .bad { color:#ef4444; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

  #canvases { position:relative; padding:12px; }
  /* Clear visual separation */
  .section-title { color:#93c5fd; margin:4px 0; }
  #pivotCanvas {
    border: 2px solid #334155;
    background: #0b1220;
    margin-bottom: 12px;
    width:100%; display:block;
  }
  .worker-hidden #pivotCanvas {
    height: calc(100vh - 140px);
  }
  .worker-visible #pivotCanvas {
    height: 55vh;
  }
  #fpsCanvas {
    position:absolute; right:20px; top:46px;
    width:240px; height:80px;
    border:1px solid #334155; background:rgba(8,12,20,.7);
  }
  #workerCanvas {
    border: 2px dashed #475569;
    background: #111827;
    width:100%; height:35vh; display:block;
    margin-top: 8px;
  }
  pre { white-space:pre-wrap; word-break:break-word; }
</style>
</head>
<body>
<div id="wrap">
  <div id="canvases" class="worker-hidden">
    <button id="togglePanel">Hide Panel â–¶</button>
    <h2 class="section-title">Pivot Scene (Christmas Tree ðŸŽ„ + Line Tests)</h2>
    <canvas id="pivotCanvas" class="gl"></canvas>
    <canvas id="fpsCanvas" class="fps"></canvas>

    <div id="workerSection">
      <h2 class="section-title">Worker Demo (Animated Triangle)</h2>
      <canvas id="workerCanvas"></canvas>
    </div>
  </div>

  <div id="panel">
    <h1>ANGLE / WebGL diagnostics</h1>
    <p>Tests WebGL via ANGLE on Windows (Edge/Chrome). Includes renderer strings, GPU caps,
       FPS graph, 3D pivot cube, OffscreenCanvas worker triangle, context-loss tests, and diagnostics export.</p>

    <h2>Renderer info</h2>
    <ul id="status"></ul>
    <pre id="info" class="mono">Collectingâ€¦</pre>

    <h2>Controls</h2>
    <div class="row">
      <button id="toggleRotation">Start Rotation</button>
      <button id="toggleCube">Show Cube</button>
      <button id="resetPivot">Reset 3D pivot</button>
    </div>
    <div class="row">
      <label>Cube Size: <input type="range" id="cubeSize" min="0.5" max="3" step="0.1" value="1.5" style="width:120px;vertical-align:middle;"> <span id="cubeSizeValue">1.5</span></label>
    </div>

    <h2>Camera Defaults</h2>
    <p style="font-size:0.85em;color:#94a3b8;margin-top:-8px;">Set initial camera position (applied on page load). Try: yaw=35Â°, pitch=-35Â°, zoom=-30</p>
    <div class="row" style="flex-wrap: wrap; gap: 8px;">
      <label>Yaw (Â°): <input type="number" id="defaultYaw" value="30" step="1" style="width:60px;"></label>
      <label>Pitch (Â°): <input type="number" id="defaultPitch" value="-30" step="1" style="width:60px;"></label>
      <label>Zoom: <input type="number" id="defaultZoom" value="-30" step="0.5" style="width:60px;"></label>
    </div>
    <div class="row">
      <button id="applyDefaults">Apply Defaults</button>
      <button id="setCurrent">Set Current as Default</button>
    </div>

    <h2>Tests</h2>
    <div class="row">
      <button id="testCanvasVisible">Test Canvas Visibility</button>
      <button id="testSimpleTriangle">Test Simple 2D Triangle</button>
      <button id="toggleDepthTest">Disable Depth Test</button>
    </div>
    <div class="row">
      <button id="simulateLossMain">Simulate loss (main)</button>
      <button id="simulateLossWorker">Simulate loss (worker)</button>
      <button id="toggleWorker">Start worker render</button>
      <button id="downloadDiag">Download diagnostics JSON</button>
    </div>
    <p>Edge GPU page: <span class="mono">edge://gpu</span> &nbsp; | &nbsp; Chrome GPU page: <span class="mono">chrome://gpu</span></p>

    <h2>ANGLE Backend Testing</h2>
    <p style="font-size:0.9em;">Current backend: <strong id="angleBackend" class="mono">Detecting...</strong></p>
    <p style="font-size:0.9em;margin-top:4px;">Chrome supports 4 ANGLE backends (chrome://flags/#use-angle):</p>
    <ul style="font-size:0.85em;line-height:1.5;">
      <li><strong>D3D11</strong> - Default. Direct3D 11 (best performance, may have line rendering issues)</li>
      <li><strong>D3D11on12</strong> - D3D11 via D3D12 (newer, testing)</li>
      <li><strong>D3D9</strong> - Legacy Direct3D 9 (compatibility)</li>
      <li><strong>D3D11 WARP</strong> - Software rasterizer (fixes line rendering, slower performance)</li>
    </ul>
    <p style="font-size:0.85em;color:#94a3b8;margin-top:8px;">
      <strong>Known issue:</strong> D3D11 may render curved lines instead of straight lines.
      D3D11 WARP fixes this but may impact performance on some devices.
    </p>

    <h2>Notes for SOE</h2>
    <ul>
      <li>If <span class="mono">WEBGL_debug_renderer_info</span> is blocked by policy, vendor/renderer may be masked.</li>
      <li>On Windows + Edge Stable, renderer should include <span class="mono">ANGLE</span> and <span class="mono">Direct3D11</span>.</li>
      <li>Use <span class="mono">edge://gpu</span> for final confirmation and driver details.</li>
    </ul>
  </div>
</div>

<script>
/* -------------------- Utility & UI -------------------- */
const statusUl = document.getElementById('status');
function addStatus(text, cls='ok') {
  const li = document.createElement('li'); li.textContent = text; li.className = cls; statusUl.appendChild(li);
  console.log(`[STATUS:${cls}] ${text}`);
}
const infoPre = document.getElementById('info');
function setInfo(lines) { infoPre.textContent = lines.join('\n'); }

/* WebGL error checking */
function checkGLError(gl, context) {
  const err = gl.getError();
  if (err !== gl.NO_ERROR) {
    const errStr = `GL_ERROR in ${context}: ${err} (0x${err.toString(16)})`;
    console.error(errStr);
    addStatus(errStr, 'bad');
    return true;
  }
  return false;
}

/* -------------------- Create GL context -------------------- */
function createGL(canvas, preferWebGL2=true) {
  const opts = { alpha:false, antialias:true, preserveDrawingBuffer:false, powerPreference:'high-performance' };
  let gl = preferWebGL2 ? canvas.getContext('webgl2', opts) : null;
  let api = gl ? 'WebGL2' : 'WebGL1';
  if (!gl) { gl = canvas.getContext('webgl', opts) || canvas.getContext('experimental-webgl', opts); api = gl ? 'WebGL1' : 'None'; }
  return { gl, api };
}

/* -------------------- Renderer info -------------------- */
function getRendererInfo(gl) {
  const dbg = gl.getExtension('WEBGL_debug_renderer_info');
  const vendor = dbg ? gl.getParameter(dbg.UNMASKED_VENDOR_WEBGL) : gl.getParameter(gl.VENDOR);
  const renderer = dbg ? gl.getParameter(dbg.UNMASKED_RENDERER_WEBGL) : gl.getParameter(gl.RENDERER);
  const shading = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);
  const version = gl.getParameter(gl.VERSION);
  const caps = {
    MAX_TEXTURE_SIZE: gl.getParameter(gl.MAX_TEXTURE_SIZE),
    MAX_CUBE_MAP_TEXTURE_SIZE: gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE),
    MAX_VERTEX_ATTRIBS: gl.getParameter(gl.MAX_VERTEX_ATTRIBS),
    MAX_VERTEX_UNIFORM_VECTORS: gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS),
    MAX_FRAGMENT_UNIFORM_VECTORS: gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS),
    MAX_VARYING_VECTORS: gl.getParameter(gl.MAX_VARYING_VECTORS),
  };
  return { vendor, renderer, shading, version, debugExt: !!dbg, caps };
}

/* -------------------- FPS graph -------------------- */
class FpsGraph {
  constructor(canvas, maxSamples=240) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.samples = new Array(maxSamples).fill(0);
    this.ptr = 0;
    this.frameCount = 0; this.lastSecond = performance.now(); this.fps = 0;
    const w = canvas.clientWidth || 240, h = canvas.clientHeight || 80;
    canvas.width = w; canvas.height = h;
  }
  tick() {
    const now = performance.now();
    this.frameCount++;
    if (now - this.lastSecond >= 1000) {
      this.fps = this.frameCount; this.frameCount = 0; this.lastSecond = now;
      this.samples[this.ptr] = this.fps; this.ptr = (this.ptr + 1) % this.samples.length;
      this.draw();
    }
  }
  draw() {
    const {ctx, canvas} = this;
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = '#93c5fd'; ctx.font = '12px system-ui'; ctx.fillText(`FPS: ${this.fps}`, 8, 14);
    const maxFps = 120, barW = w/this.samples.length;
    for (let i=0; i<this.samples.length; i++) {
      const idx = (this.ptr + i) % this.samples.length;
      const v = this.samples[idx];
      const barH = Math.min(h-24, Math.floor((v/maxFps) * (h-24)));
      ctx.fillStyle = v >= 55 ? '#22c55e' : (v >= 40 ? '#f59e0b' : '#ef4444');
      ctx.fillRect(i*barW, h - barH - 4, barW-1, barH);
    }
  }
  snapshot() { return { fps: this.fps, samples: [...this.samples] }; }
}

/* -------------------- Minimal matrix math -------------------- */
function matMul(a,b){const r=new Float32Array(16);for(let i=0;i<4;i++){for(let j=0;j<4;j++){let s=0;for(let k=0;k<4;k++)s+=a[i*4+k]*b[k*4+j];r[i*4+j]=s;}}return r;}
function matIdentity(){const m=new Float32Array(16);m[0]=m[5]=m[10]=m[15]=1;return m;}
function matPerspective(fovy,aspect,near,far){const f=1/Math.tan(fovy/2),nf=1/(near-far);const m=new Float32Array(16);
  m[0]=f/aspect;m[5]=f;m[10]=(far+near)*nf;m[11]=-1;m[14]=(2*far*near)*nf;return m;}
function matTranslate(tx,ty,tz){const m=matIdentity();m[12]=tx;m[13]=ty;m[14]=tz;return m;}
function matRotateY(a){const c=Math.cos(a),s=Math.sin(a);const m=matIdentity();m[0]=c;m[2]=s;m[8]=-s;m[10]=c;return m;}
function matRotateX(a){const c=Math.cos(a),s=Math.sin(a);const m=matIdentity();m[5]=c;m[6]=-s;m[9]=s;m[10]=c;return m;}
function matScale(sx,sy,sz){const m=matIdentity();m[0]=sx;m[5]=sy;m[10]=sz;return m;}

/* -------------------- BÃ©zier curve math -------------------- */
// Cubic BÃ©zier: B(t) = (1-t)Â³P0 + 3(1-t)Â²tP1 + 3(1-t)tÂ²P2 + tÂ³P3
function cubicBezier(p0, p1, p2, p3, t) {
  const mt = 1 - t;
  const mt2 = mt * mt;
  const mt3 = mt2 * mt;
  const t2 = t * t;
  const t3 = t2 * t;

  return {
    x: mt3 * p0.x + 3 * mt2 * t * p1.x + 3 * mt * t2 * p2.x + t3 * p3.x,
    y: mt3 * p0.y + 3 * mt2 * t * p1.y + 3 * mt * t2 * p2.y + t3 * p3.y
  };
}

// Quadratic BÃ©zier: B(t) = (1-t)Â²P0 + 2(1-t)tP1 + tÂ²P2
function quadraticBezier(p0, p1, p2, t) {
  const mt = 1 - t;
  const mt2 = mt * mt;
  const t2 = t * t;

  return {
    x: mt2 * p0.x + 2 * mt * t * p1.x + t2 * p2.x,
    y: mt2 * p0.y + 2 * mt * t * p1.y + t2 * p2.y
  };
}

// Generate points along a BÃ©zier curve
function generateBezierPoints(controlPoints, segments = 50, cubic = true) {
  const points = [];
  for (let i = 0; i <= segments; i++) {
    const t = i / segments;
    let pt;
    if (cubic && controlPoints.length === 4) {
      pt = cubicBezier(controlPoints[0], controlPoints[1], controlPoints[2], controlPoints[3], t);
    } else if (!cubic && controlPoints.length === 3) {
      pt = quadraticBezier(controlPoints[0], controlPoints[1], controlPoints[2], t);
    }
    if (pt) points.push(pt);
  }
  return points;
}

/* -------------------- Build 3D pivot scene -------------------- */
const pivotCanvas = document.getElementById('pivotCanvas');
const fpsCanvas = document.getElementById('fpsCanvas');
console.log('Initializing pivot canvas...', { width: pivotCanvas.width, height: pivotCanvas.height, clientWidth: pivotCanvas.clientWidth, clientHeight: pivotCanvas.clientHeight });
const { gl: pivotGL, api: pivotAPI } = createGL(pivotCanvas, true);
if (!pivotGL) {
  addStatus('Failed to create WebGL context (pivot). WebGL may be blocked by policy or GPU.', 'bad');
  console.error('pivotGL is null - WebGL context creation failed');
} else {
  addStatus(`Created ${pivotAPI} context (pivot).`);
  console.log('pivotGL context created:', { api: pivotAPI, canvas: pivotCanvas });
}

const ri = pivotGL ? getRendererInfo(pivotGL) : null;
if (ri) {
  setInfo([
    `API            : ${pivotAPI}`,
    `GL_VERSION     : ${ri.version}`,
    `GLSL_VERSION   : ${ri.shading}`,
    `Vendor         : ${ri.vendor}`,
    `Renderer       : ${ri.renderer}`,
    `Debug ext      : ${ri.debugExt ? 'WEBGL_debug_renderer_info available' : 'not available'}`,
    `Caps           : ${JSON.stringify(ri.caps)}`
  ]);

  // Detect ANGLE backend from renderer string
  const angleBackendEl = document.getElementById('angleBackend');
  if (angleBackendEl) {
    const renderer = ri.renderer.toLowerCase();
    let backend = 'Unknown';
    if (renderer.includes('warp')) {
      backend = 'D3D11 WARP (Software)';
    } else if (renderer.includes('d3d11on12') || renderer.includes('direct3d11on12')) {
      backend = 'D3D11on12';
    } else if (renderer.includes('d3d11') || renderer.includes('direct3d11')) {
      backend = 'D3D11 (Hardware)';
    } else if (renderer.includes('d3d9') || renderer.includes('direct3d9')) {
      backend = 'D3D9 (Legacy)';
    } else if (renderer.includes('opengl')) {
      backend = 'OpenGL (Deprecated)';
    } else if (renderer.includes('metal')) {
      backend = 'Metal (macOS/iOS)';
    }
    angleBackendEl.textContent = backend;
    angleBackendEl.style.color = backend.includes('WARP') ? '#f59e0b' : '#22c55e';
    console.log('ANGLE backend detected:', backend, '| Full renderer:', ri.renderer);
  }
}

const fps = new FpsGraph(fpsCanvas);

/* Shaders: WebGL2 (ES 3.0) + WebGL1 (ES 2.0) with precision aligned */
const v300 = `#version 300 es
uniform highp mat4 uMVP;
uniform highp float uTime;

layout(location=0) in vec3 aPos;
layout(location=1) in vec3 aCol;

out vec3 vCol;

void main() {
  float wobble = 0.02 * sin(uTime * 0.6);
  gl_Position = uMVP * vec4(aPos + vec3(0.0, wobble, 0.0), 1.0);
  vCol = aCol;
}`;
const f300 = `#version 300 es
precision highp float;

in vec3 vCol;
out vec4 outColor;

void main() {
  outColor = vec4(vCol, 1.0);
}`;

const vES2 = `
attribute vec3 aPos;
attribute vec3 aCol;

uniform highp mat4 uMVP;
uniform highp float uTime;

varying vec3 vCol;

void main() {
  float wobble = 0.02 * sin(uTime * 0.6);
  gl_Position = uMVP * vec4(aPos + vec3(0.0, wobble, 0.0), 1.0);
  vCol = aCol;
}`;
const fES2 = `
precision highp float;

varying vec3 vCol;

void main() {
  gl_FragColor = vec4(vCol, 1.0);
}`;

function compile(gl,type,src){const s=gl.createShader(type);gl.shaderSource(s,src);gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)||'Shader compile error'); return s;}
function link(gl,vs,fs){const p=gl.createProgram();gl.attachShader(p,vs);gl.attachShader(p,fs);gl.linkProgram(p);
  if(!gl.getProgramParameter(p,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p)||'Program link error'); return p;}

let program=null, vao=null, vbo=null, ibo=null, uMVP=null, uTime=null;
let locPos=-1, locCol=-1;

// Simple 2D test program (no transformations)
let testProgram=null, testVAO=null, testVBO=null;

// Terrain rendering (Mt Cook profile with BÃ©zier curves)
let terrainProgram=null, terrainVAO=null, terrainVBO=null, terrainIBO=null, terrainCount=0;
let terrainMVP=null;
let terrainIndexCount=0;
let gridProgram=null, gridVAO=null, gridVBO=null, gridCount=0;
let gridMVP=null;
let lineTestProgram=null, lineTestVAO=null, lineTestVBO=null, lineTestCount=0;

if (pivotGL) {
  try {
    console.log(`Compiling shaders for ${pivotAPI}...`);
    if (pivotAPI === 'WebGL2') {
      const vs = compile(pivotGL, pivotGL.VERTEX_SHADER, v300);
      console.log('WebGL2 vertex shader compiled');
      const fs = compile(pivotGL, pivotGL.FRAGMENT_SHADER, f300);
      console.log('WebGL2 fragment shader compiled');
      program = link(pivotGL, vs, fs);
      console.log('WebGL2 program linked');
      vao = pivotGL.createVertexArray();
      pivotGL.bindVertexArray(vao);
      console.log('WebGL2 VAO created and bound');
      locPos = 0; locCol = 1;
    } else {
      const vs = compile(pivotGL, pivotGL.VERTEX_SHADER, vES2);
      console.log('WebGL1 vertex shader compiled');
      const fs = compile(pivotGL, pivotGL.FRAGMENT_SHADER, fES2);
      console.log('WebGL1 fragment shader compiled');
      program = link(pivotGL, vs, fs);
      console.log('WebGL1 program linked');
      locPos = pivotGL.getAttribLocation(program, 'aPos');
      locCol = pivotGL.getAttribLocation(program, 'aCol');
      console.log('WebGL1 attribute locations:', { locPos, locCol });
    }

    // Cube geometry (scaled Ã—1.5 for visibility), pos+color interleaved
    const s = 1.5;
    const verts = new Float32Array([
      // x, y, z,   r, g, b
      -s,-s,-s,   1,0,0,   // 0
       s,-s,-s,   0,1,0,   // 1
       s, s,-s,   0,0,1,   // 2
      -s, s,-s,   1,1,0,   // 3
      -s,-s, s,   1,0,1,   // 4
       s,-s, s,   0,1,1,   // 5
       s, s, s,   1,1,1,   // 6
      -s, s, s,   0.3,0.8,0.5 // 7
    ]);
    const idx = new Uint16Array([
      0,1,2, 0,2,3, // back
      4,5,6, 4,6,7, // front
      0,4,7, 0,7,3, // left
      1,5,6, 1,6,2, // right
      3,2,6, 3,6,7, // top
      0,1,5, 0,5,4  // bottom
    ]);

    if (vao) pivotGL.bindVertexArray(vao);

    vbo = pivotGL.createBuffer();
    pivotGL.bindBuffer(pivotGL.ARRAY_BUFFER, vbo);
    pivotGL.bufferData(pivotGL.ARRAY_BUFFER, verts, pivotGL.STATIC_DRAW);

    ibo = pivotGL.createBuffer();
    pivotGL.bindBuffer(pivotGL.ELEMENT_ARRAY_BUFFER, ibo);
    pivotGL.bufferData(pivotGL.ELEMENT_ARRAY_BUFFER, idx, pivotGL.STATIC_DRAW);

    const stride = 6 * 4;       // 6 floats per vertex = 24 bytes
    const offsetPos = 0;        // bytes
    const offsetCol = 3 * 4;    // bytes

    pivotGL.vertexAttribPointer(locPos, 3, pivotGL.FLOAT, false, stride, offsetPos);
    pivotGL.enableVertexAttribArray(locPos);
    pivotGL.vertexAttribPointer(locCol, 3, pivotGL.FLOAT, false, stride, offsetCol);
    pivotGL.enableVertexAttribArray(locCol);

    pivotGL.useProgram(program);
    uMVP = pivotGL.getUniformLocation(program,'uMVP');
    uTime = pivotGL.getUniformLocation(program,'uTime');
    console.log('Uniform locations:', { uMVP, uTime });

    checkGLError(pivotGL, 'after pivot setup');

    // Verify buffer contains data
    pivotGL.bindBuffer(pivotGL.ARRAY_BUFFER, vbo);
    const bufferSize = pivotGL.getBufferParameter(pivotGL.ARRAY_BUFFER, pivotGL.BUFFER_SIZE);
    console.log('VBO buffer size:', bufferSize, 'bytes (expected 192 = 8 vertices * 6 floats * 4 bytes)');

    pivotGL.bindBuffer(pivotGL.ELEMENT_ARRAY_BUFFER, ibo);
    const indexBufferSize = pivotGL.getBufferParameter(pivotGL.ELEMENT_ARRAY_BUFFER, pivotGL.BUFFER_SIZE);
    console.log('IBO buffer size:', indexBufferSize, 'bytes (expected 72 = 36 indices * 2 bytes)');

    addStatus('3D pivot program compiled/linked.');
    console.log('Pivot setup OK', {
      api: pivotAPI,
      vao: !!vao,
      vbo: !!vbo,
      ibo: !!ibo,
      locPos,
      locCol,
      uMVP,
      uTime,
      program: !!program
    });
  } catch (e) {
    addStatus('Pivot shader/program error: '+e.message, 'bad');
    console.error('Pivot setup error:', e);
  }

  // Create simple 2D test program (clip-space coordinates, no transformations)
  try {
    console.log('Creating simple 2D test program...');
    const testVS = pivotAPI === 'WebGL2' ? `#version 300 es
      layout(location=0) in vec2 aPos;
      void main() { gl_Position = vec4(aPos, 0.0, 1.0); }
    ` : `
      attribute vec2 aPos;
      void main() { gl_Position = vec4(aPos, 0.0, 1.0); }
    `;

    const testFS = pivotAPI === 'WebGL2' ? `#version 300 es
      precision highp float;
      out vec4 outColor;
      void main() { outColor = vec4(1.0, 0.5, 0.0, 1.0); }
    ` : `
      precision highp float;
      void main() { gl_FragColor = vec4(1.0, 0.5, 0.0, 1.0); }
    `;

    const vs = compile(pivotGL, pivotGL.VERTEX_SHADER, testVS);
    const fs = compile(pivotGL, pivotGL.FRAGMENT_SHADER, testFS);
    testProgram = link(pivotGL, vs, fs);

    if (pivotAPI === 'WebGL2') {
      testVAO = pivotGL.createVertexArray();
      pivotGL.bindVertexArray(testVAO);
    }

    testVBO = pivotGL.createBuffer();
    pivotGL.bindBuffer(pivotGL.ARRAY_BUFFER, testVBO);
    // Large triangle in clip space
    const triVerts = new Float32Array([
      -0.8, -0.8,
       0.8, -0.8,
       0.0,  0.8
    ]);
    pivotGL.bufferData(pivotGL.ARRAY_BUFFER, triVerts, pivotGL.STATIC_DRAW);

    const testLocPos = pivotAPI === 'WebGL2' ? 0 : pivotGL.getAttribLocation(testProgram, 'aPos');
    pivotGL.vertexAttribPointer(testLocPos, 2, pivotGL.FLOAT, false, 0, 0);
    pivotGL.enableVertexAttribArray(testLocPos);

    // IMPORTANT: Unbind test VAO to restore previous state
    if (pivotAPI === 'WebGL2') {
      pivotGL.bindVertexArray(null);
      console.log('Test VAO unbound');
    }

    console.log('Simple 2D test program ready');
  } catch (e) {
    console.error('2D test program setup error:', e);
  }

  // Create terrain renderer (Mt Cook profile with BÃ©zier curves)
  try {
    console.log('Creating Mt Cook terrain renderer...');

    // Shaders for line rendering
    const terrainVS = pivotAPI === 'WebGL2' ? `#version 300 es
      uniform highp mat4 uMVP;
      layout(location=0) in vec3 aPos;
      layout(location=1) in vec3 aCol;
      out vec3 vCol;
      void main() {
        gl_Position = uMVP * vec4(aPos, 1.0);
        vCol = aCol;
      }
    ` : `
      uniform highp mat4 uMVP;
      attribute vec3 aPos;
      attribute vec3 aCol;
      varying vec3 vCol;
      void main() {
        gl_Position = uMVP * vec4(aPos, 1.0);
        vCol = aCol;
      }
    `;

    const terrainFS = pivotAPI === 'WebGL2' ? `#version 300 es
      precision highp float;
      in vec3 vCol;
      out vec4 outColor;
      void main() { outColor = vec4(vCol, 1.0); }
    ` : `
      precision highp float;
      varying vec3 vCol;
      void main() { gl_FragColor = vec4(vCol, 1.0); }
    `;

    const vs = compile(pivotGL, pivotGL.VERTEX_SHADER, terrainVS);
    const fs = compile(pivotGL, pivotGL.FRAGMENT_SHADER, terrainFS);
    terrainProgram = link(pivotGL, vs, fs);
    terrainMVP = pivotGL.getUniformLocation(terrainProgram, 'uMVP');

    // Generate 3D Christmas Tree - festive cone centered on plane
    // Tree centered at (0, 0, 0) with radial symmetry
    const terrainVerts = [];
    const heightLevels = 30;  // Number of height rings (base to peak)
    const angularSegments = 32;  // Number of segments around the tree
    const baseRadius = 4;     // Radius at base (y=0)
    const peakHeight = 8;     // Height of tree
    const centerZ = 0;        // Z position (centered on ground plane)

    // Generate vertices with Christmas colors for each height level
    for (let level = 0; level <= heightLevels; level++) {
      const t = level / heightLevels;  // 0 (base) to 1 (peak)
      const y = t * peakHeight;        // Linear height

      // Tiered Christmas tree shape (3 tiers)
      let radiusMultiplier;
      if (t < 0.12) {
        // Trunk (brown cylinder)
        radiusMultiplier = 0.15;
      } else if (t < 0.35) {
        // Bottom tier
        radiusMultiplier = (1 - (t - 0.12) / 0.23) * 0.95;
      } else if (t < 0.65) {
        // Middle tier
        radiusMultiplier = (1 - (t - 0.35) / 0.30) * 0.75;
      } else if (t < 0.90) {
        // Top tier
        radiusMultiplier = (1 - (t - 0.65) / 0.25) * 0.55;
      } else {
        // Star at top
        radiusMultiplier = 0.15;
      }

      const radius = baseRadius * radiusMultiplier;

      // Christmas tree colors: brown trunk, green foliage, gold star
      let r, g, b;
      if (t < 0.12) {
        // Trunk: brown (0.0 - 0.12)
        r = 0.4;
        g = 0.25;
        b = 0.15;
      } else if (t < 0.90) {
        // Tree foliage: green (0.12 - 0.90)
        const greenBase = 0.1 + (Math.sin(t * Math.PI * 8) * 0.05);  // Slight variation
        r = greenBase;
        g = 0.4 + (Math.sin(t * Math.PI * 6) * 0.1);  // Darker green
        b = 0.1;
      } else {
        // Star at top: gold/yellow (0.90 - 1.0)
        r = 1.0;
        g = 0.85;
        b = 0.2;
      }

      // Add ornament-like colored spots randomly on the green parts
      const ornamentSeed = Math.sin(level * 7.89) * Math.cos(level * 3.14);
      const hasOrnament = t >= 0.12 && t < 0.90 && ornamentSeed > 0.7;

      if (hasOrnament) {
        // Random ornament colors (red, gold, blue, silver)
        const ornamentType = (level % 4);
        if (ornamentType === 0) { r = 0.9; g = 0.1; b = 0.1; }       // Red
        else if (ornamentType === 1) { r = 1.0; g = 0.8; b = 0.0; }  // Gold
        else if (ornamentType === 2) { r = 0.1; g = 0.4; b = 0.9; }  // Blue
        else { r = 0.8; g = 0.8; b = 0.9; }                          // Silver
      }

      // Create ring of vertices at this height
      for (let seg = 0; seg < angularSegments; seg++) {
        const angle = (seg / angularSegments) * Math.PI * 2;

        const x = Math.cos(angle) * radius;
        const z = centerZ + Math.sin(angle) * radius;

        terrainVerts.push(x, y, z, r, g, b);
      }
    }

    // Add apex vertex at peak (star point at top) - bright gold
    terrainVerts.push(0, peakHeight, centerZ, 1.0, 0.85, 0.2);

    terrainCount = terrainVerts.length / 6;  // Now 6 floats per vertex (x,y,z,r,g,b)

    // Generate indices for 3D cone mesh
    const terrainIndices = [];
    const apexIndex = terrainCount - 1;  // Last vertex is apex

    // Connect height levels with quads (2 triangles each)
    for (let level = 0; level < heightLevels; level++) {
      const levelStart = level * angularSegments;
      const nextLevelStart = (level + 1) * angularSegments;

      for (let seg = 0; seg < angularSegments; seg++) {
        const nextSeg = (seg + 1) % angularSegments;

        const v0 = levelStart + seg;
        const v1 = levelStart + nextSeg;
        const v2 = nextLevelStart + seg;
        const v3 = nextLevelStart + nextSeg;

        // Create two triangles for each quad
        terrainIndices.push(v0, v2, v1);
        terrainIndices.push(v1, v2, v3);
      }
    }

    // Connect top level to apex
    const topLevelStart = heightLevels * angularSegments;
    for (let seg = 0; seg < angularSegments; seg++) {
      const nextSeg = (seg + 1) % angularSegments;
      terrainIndices.push(topLevelStart + seg, apexIndex, topLevelStart + nextSeg);
    }

    terrainIndexCount = terrainIndices.length;

    if (pivotAPI === 'WebGL2') {
      terrainVAO = pivotGL.createVertexArray();
      pivotGL.bindVertexArray(terrainVAO);
    }

    terrainVBO = pivotGL.createBuffer();
    pivotGL.bindBuffer(pivotGL.ARRAY_BUFFER, terrainVBO);
    pivotGL.bufferData(pivotGL.ARRAY_BUFFER, new Float32Array(terrainVerts), pivotGL.STATIC_DRAW);

    terrainIBO = pivotGL.createBuffer();
    pivotGL.bindBuffer(pivotGL.ELEMENT_ARRAY_BUFFER, terrainIBO);
    pivotGL.bufferData(pivotGL.ELEMENT_ARRAY_BUFFER, new Uint16Array(terrainIndices), pivotGL.STATIC_DRAW);

    // Setup interleaved vertex attributes (position + color)
    const stride = 6 * 4;  // 6 floats per vertex * 4 bytes per float
    const terrainLocPos = pivotAPI === 'WebGL2' ? 0 : pivotGL.getAttribLocation(terrainProgram, 'aPos');
    const terrainLocCol = pivotAPI === 'WebGL2' ? 1 : pivotGL.getAttribLocation(terrainProgram, 'aCol');

    pivotGL.vertexAttribPointer(terrainLocPos, 3, pivotGL.FLOAT, false, stride, 0);
    pivotGL.enableVertexAttribArray(terrainLocPos);

    pivotGL.vertexAttribPointer(terrainLocCol, 3, pivotGL.FLOAT, false, stride, 12);
    pivotGL.enableVertexAttribArray(terrainLocCol);

    if (pivotAPI === 'WebGL2') {
      pivotGL.bindVertexArray(null);
    }

    console.log(`Mt Cook terrain ready (${terrainCount} vertices, ${terrainIndexCount} indices, ${terrainIndexCount/3} triangles)`);
  } catch (e) {
    console.error('Terrain setup error:', e);
  }

  // Create ground grid plane at y=0
  try {
    console.log('Creating ground grid plane...');

    // Reuse terrain shaders (same structure - position-only, MVP transform)
    gridProgram = terrainProgram;  // Use same shader program
    gridMVP = terrainMVP;           // Use same uniform location

    // Generate grid lines at y=0 (ground plane)
    const gridVerts = [];
    const gridSize = 20;      // Grid extends from -10 to +10 in X and Z
    const gridSpacing = 1;    // 1 unit spacing
    const gridMin = -10;
    const gridMax = 10;
    const y = 0;              // Ground level

    // Lines parallel to X-axis (varying Z) - darker gray
    for (let z = gridMin; z <= gridMax; z += gridSpacing) {
      const brightness = (z === 0) ? 0.6 : 0.3;  // Brighter on axes
      gridVerts.push(gridMin, y, z, brightness, brightness, brightness);
      gridVerts.push(gridMax, y, z, brightness, brightness, brightness);
    }

    // Lines parallel to Z-axis (varying X) - darker gray
    for (let x = gridMin; x <= gridMax; x += gridSpacing) {
      const brightness = (x === 0) ? 0.6 : 0.3;  // Brighter on axes
      gridVerts.push(x, y, gridMin, brightness, brightness, brightness);
      gridVerts.push(x, y, gridMax, brightness, brightness, brightness);
    }

    gridCount = gridVerts.length / 6;  // Now 6 floats per vertex (x,y,z,r,g,b)

    if (pivotAPI === 'WebGL2') {
      gridVAO = pivotGL.createVertexArray();
      pivotGL.bindVertexArray(gridVAO);
    }

    gridVBO = pivotGL.createBuffer();
    pivotGL.bindBuffer(pivotGL.ARRAY_BUFFER, gridVBO);
    pivotGL.bufferData(pivotGL.ARRAY_BUFFER, new Float32Array(gridVerts), pivotGL.STATIC_DRAW);

    // Setup interleaved attributes (position + color)
    const gridStride = 6 * 4;
    const gridLocPos = pivotAPI === 'WebGL2' ? 0 : pivotGL.getAttribLocation(gridProgram, 'aPos');
    const gridLocCol = pivotAPI === 'WebGL2' ? 1 : pivotGL.getAttribLocation(gridProgram, 'aCol');
    pivotGL.vertexAttribPointer(gridLocPos, 3, pivotGL.FLOAT, false, gridStride, 0);
    pivotGL.enableVertexAttribArray(gridLocPos);
    pivotGL.vertexAttribPointer(gridLocCol, 3, pivotGL.FLOAT, false, gridStride, 12);
    pivotGL.enableVertexAttribArray(gridLocCol);

    if (pivotAPI === 'WebGL2') {
      pivotGL.bindVertexArray(null);
    }

    console.log(`Ground grid ready (${gridCount} vertices, ${gridCount/2} lines)`);
  } catch (e) {
    console.error('Grid setup error:', e);
  }

  // Create line test patterns for ANGLE D3D11 curved line issue
  try {
    console.log('Creating line test patterns...');

    lineTestProgram = terrainProgram;  // Reuse terrain shader

    const lineTestVerts = [];
    const testY = 3;  // Height above ground for visibility
    const centerZ = 0;  // Match terrain center position

    // Radial lines from center (should be straight, may appear curved on D3D11)
    const radialLines = 16;
    const radialRadius = 4;
    for (let i = 0; i < radialLines; i++) {
      const angle = (i / radialLines) * Math.PI * 2;
      const x = Math.cos(angle) * radialRadius;
      const z = centerZ + Math.sin(angle) * radialRadius;
      // Center point (yellow)
      lineTestVerts.push(0, testY, centerZ, 1.0, 1.0, 0.0);
      // Outer point (yellow)
      lineTestVerts.push(x, testY, z, 1.0, 1.0, 0.0);
    }

    // Crossing diagonal lines (form an X pattern)
    const diag = 5;
    // Line 1: NW to SE (red)
    lineTestVerts.push(-diag, testY + 0.5, centerZ - diag, 1.0, 0.0, 0.0);
    lineTestVerts.push(diag, testY + 0.5, centerZ + diag, 1.0, 0.0, 0.0);
    // Line 2: NE to SW (cyan)
    lineTestVerts.push(diag, testY + 0.5, centerZ - diag, 0.0, 1.0, 1.0);
    lineTestVerts.push(-diag, testY + 0.5, centerZ + diag, 0.0, 1.0, 1.0);

    // Horizontal and vertical test lines (should be perfectly straight)
    // Horizontal line (magenta)
    lineTestVerts.push(-6, testY + 1, centerZ, 1.0, 0.0, 1.0);
    lineTestVerts.push(6, testY + 1, centerZ, 1.0, 0.0, 1.0);
    // Vertical line (green)
    lineTestVerts.push(0, testY + 1, centerZ - 6, 0.0, 1.0, 0.0);
    lineTestVerts.push(0, testY + 1, centerZ + 6, 0.0, 1.0, 0.0);

    lineTestCount = lineTestVerts.length / 6;

    if (pivotAPI === 'WebGL2') {
      lineTestVAO = pivotGL.createVertexArray();
      pivotGL.bindVertexArray(lineTestVAO);
    }

    lineTestVBO = pivotGL.createBuffer();
    pivotGL.bindBuffer(pivotGL.ARRAY_BUFFER, lineTestVBO);
    pivotGL.bufferData(pivotGL.ARRAY_BUFFER, new Float32Array(lineTestVerts), pivotGL.STATIC_DRAW);

    const lineTestStride = 6 * 4;
    const lineTestLocPos = pivotAPI === 'WebGL2' ? 0 : pivotGL.getAttribLocation(lineTestProgram, 'aPos');
    const lineTestLocCol = pivotAPI === 'WebGL2' ? 1 : pivotGL.getAttribLocation(lineTestProgram, 'aCol');
    pivotGL.vertexAttribPointer(lineTestLocPos, 3, pivotGL.FLOAT, false, lineTestStride, 0);
    pivotGL.enableVertexAttribArray(lineTestLocPos);
    pivotGL.vertexAttribPointer(lineTestLocCol, 3, pivotGL.FLOAT, false, lineTestStride, 12);
    pivotGL.enableVertexAttribArray(lineTestLocCol);

    if (pivotAPI === 'WebGL2') {
      pivotGL.bindVertexArray(null);
    }

    console.log(`Line test patterns ready (${lineTestCount} vertices, ${lineTestCount/2} lines)`);
  } catch (e) {
    console.error('Line test setup error:', e);
  }

  // Re-bind main cube VAO to ensure it's active for rendering
  if (vao) {
    pivotGL.bindVertexArray(vao);
    console.log('Main cube VAO re-bound after test setup');
  }
}

/* Pivot interactions and cube controls */
// Camera angles in RADIANS (use degrees * Math.PI/180 for initial values)
// Example: let yaw = 35 * Math.PI / 180;  // 35 degrees
let yaw=0, pitch=0, dragging=false, lastX=0, lastY=0;
let cubeVisible = false;  // Start with cube hidden
let cubeScale = 1.5;
let rotationEnabled = false;  // Start with rotation stopped
let zoomLevel = -6;  // Camera distance

function resetPivot(){ yaw=0; pitch=0; }
document.getElementById('resetPivot').onclick = resetPivot;

// Rotation toggle
document.getElementById('toggleRotation').onclick = ()=>{
  rotationEnabled = !rotationEnabled;
  document.getElementById('toggleRotation').textContent = rotationEnabled ? 'Stop Rotation' : 'Start Rotation';
  addStatus(rotationEnabled ? 'Rotation started' : 'Rotation stopped', 'ok');
};

// Cube visibility toggle
document.getElementById('toggleCube').onclick = ()=>{
  cubeVisible = !cubeVisible;
  document.getElementById('toggleCube').textContent = cubeVisible ? 'Hide Cube' : 'Show Cube';
  addStatus(cubeVisible ? 'Cube visible' : 'Cube hidden', 'ok');
};

// Cube size control
document.getElementById('cubeSize').oninput = (e)=>{
  cubeScale = parseFloat(e.target.value);
  document.getElementById('cubeSizeValue').textContent = cubeScale.toFixed(1);
};

// Camera defaults
document.getElementById('applyDefaults').onclick = ()=>{
  const yawDeg = parseFloat(document.getElementById('defaultYaw').value);
  const pitchDeg = parseFloat(document.getElementById('defaultPitch').value);
  const zoom = parseFloat(document.getElementById('defaultZoom').value);

  yaw = yawDeg * Math.PI / 180;
  pitch = pitchDeg * Math.PI / 180;
  zoomLevel = zoom;

  addStatus(`Camera set to yaw=${yawDeg}Â°, pitch=${pitchDeg}Â°, zoom=${zoom}`, 'ok');
};

document.getElementById('setCurrent').onclick = ()=>{
  const yawDeg = (yaw * 180 / Math.PI).toFixed(1);
  const pitchDeg = (pitch * 180 / Math.PI).toFixed(1);
  const zoom = zoomLevel.toFixed(3);

  document.getElementById('defaultYaw').value = yawDeg;
  document.getElementById('defaultPitch').value = pitchDeg;
  document.getElementById('defaultZoom').value = zoom;

  addStatus(`Defaults updated to current position (yaw=${yawDeg}Â°, pitch=${pitchDeg}Â°, zoom=${zoom})`, 'ok');
};

// Apply defaults on page load
(function applyInitialDefaults() {
  const yawDeg = parseFloat(document.getElementById('defaultYaw').value);
  const pitchDeg = parseFloat(document.getElementById('defaultPitch').value);
  const zoom = parseFloat(document.getElementById('defaultZoom').value);

  yaw = yawDeg * Math.PI / 180;
  pitch = pitchDeg * Math.PI / 180;
  zoomLevel = zoom;
})();

pivotCanvas.addEventListener('pointerdown', e=>{dragging=true; lastX=e.clientX; lastY=e.clientY; pivotCanvas.setPointerCapture(e.pointerId);});
pivotCanvas.addEventListener('pointerup', e=>{
  dragging=false;
  pivotCanvas.releasePointerCapture(e.pointerId);
  // Log camera position after mouse release
  console.log('Camera Position:', {
    yaw: (yaw * 180 / Math.PI).toFixed(1) + 'Â°',
    pitch: (pitch * 180 / Math.PI).toFixed(1) + 'Â°',
    zoomLevel: zoomLevel.toFixed(3)
  });
});
pivotCanvas.addEventListener('pointermove', e=>{
  if(!dragging) return;
  const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY;
  yaw += dx*0.01; pitch += dy*0.01;
});

// Mouse wheel zoom
pivotCanvas.addEventListener('wheel', e=>{
  e.preventDefault();
  zoomLevel += e.deltaY * 0.01;
  zoomLevel = Math.max(-50, Math.min(-2, zoomLevel)); // Clamp between -50 and -2
}, {passive: false});

/* Panel toggle */
document.getElementById('togglePanel').onclick = ()=>{
  const wrap = document.getElementById('wrap');
  const panel = document.getElementById('panel');
  const btn = document.getElementById('togglePanel');
  wrap.classList.toggle('panel-collapsed');
  panel.classList.toggle('collapsed');
  btn.textContent = panel.classList.contains('collapsed') ? 'â—€ Show Panel' : 'Hide Panel â–¶';
};

/* Test buttons for diagnostics */
let flashTestRunning = false;
document.getElementById('testCanvasVisible').onclick = ()=>{
  if (!pivotGL) {
    addStatus('Cannot test - no GL context', 'bad');
    return;
  }
  if (flashTestRunning) {
    addStatus('Flash test already running', 'warn');
    return;
  }

  flashTestRunning = true;
  addStatus('Testing canvas visibility - flashing bright colors...', 'ok');
  console.log('Canvas visibility test: Flashing colors (render loop paused)');

  let count = 0;
  const colors = [
    [1, 0, 1, 1],    // Magenta
    [0, 1, 1, 1],    // Cyan
    [1, 1, 0, 1],    // Yellow
    [0, 1, 0, 1],    // Green
  ];

  function flashNext() {
    if (count >= 8) {
      flashTestRunning = false;
      addStatus('Visibility test complete. Did you see flashing colors?', 'ok');
      console.log('Visibility test complete - resuming render loop');
      requestAnimationFrame(drawPivot);
      return;
    }

    const color = colors[count % colors.length];
    pivotGL.clearColor(...color);
    pivotGL.clear(pivotGL.COLOR_BUFFER_BIT);
    console.log(`Flashing color ${count}: rgba(${color.join(', ')})`);
    count++;
    setTimeout(flashNext, 300);
  }

  flashNext();
};

let testTriangleActive = false;
document.getElementById('testSimpleTriangle').onclick = ()=>{
  if (!pivotGL) {
    addStatus('Cannot test - no GL context', 'bad');
    return;
  }

  testTriangleActive = !testTriangleActive;

  if (testTriangleActive) {
    addStatus('Simple 2D triangle test activated', 'ok');
    console.log('Drawing simple 2D triangle (clip space coordinates)');
    document.getElementById('testSimpleTriangle').textContent = 'Stop 2D Triangle Test';
  } else {
    addStatus('Simple 2D triangle test deactivated', 'ok');
    console.log('Stopping simple 2D triangle test');
    document.getElementById('testSimpleTriangle').textContent = 'Test Simple 2D Triangle';
  }
};

let depthTestDisabled = false;
document.getElementById('toggleDepthTest').onclick = ()=>{
  depthTestDisabled = !depthTestDisabled;
  if (depthTestDisabled) {
    addStatus('Depth test DISABLED for cube rendering', 'warn');
    console.log('Depth test disabled - cube should render without depth testing');
    document.getElementById('toggleDepthTest').textContent = 'Enable Depth Test';
  } else {
    addStatus('Depth test ENABLED for cube rendering', 'ok');
    console.log('Depth test enabled - normal 3D rendering');
    document.getElementById('toggleDepthTest').textContent = 'Disable Depth Test';
  }
};

/* Resize + draw loop (with robust size guards) */
function resizeCanvas(gl,canvas){
  const w = canvas.clientWidth || 640, h = canvas.clientHeight || 360;
  if (canvas.width!==w || canvas.height!==h) {
    console.log(`Resizing canvas from ${canvas.width}x${canvas.height} to ${w}x${h}`);
    canvas.width=w; canvas.height=h;
  }
  gl.viewport(0,0,w,h);
}
let startTime = performance.now();

function drawPivot(){
  if (!pivotGL || !program) {
    console.error('drawPivot called but missing pivotGL or program', { pivotGL: !!pivotGL, program: !!program });
    return;
  }

  // Pause rendering during flash test
  if (flashTestRunning) {
    return;
  }

  resizeCanvas(pivotGL, pivotCanvas);

  pivotGL.clearColor(0.07,0.09,0.16,1);
  pivotGL.clear(pivotGL.COLOR_BUFFER_BIT|pivotGL.DEPTH_BUFFER_BIT);

  // Simple 2D triangle test mode
  if (testTriangleActive && testProgram) {
    pivotGL.disable(pivotGL.DEPTH_TEST);
    pivotGL.useProgram(testProgram);
    if (testVAO) {
      pivotGL.bindVertexArray(testVAO);
    } else {
      // Rebind for WebGL1
      pivotGL.bindBuffer(pivotGL.ARRAY_BUFFER, testVBO);
      const testLocPos = pivotGL.getAttribLocation(testProgram, 'aPos');
      pivotGL.vertexAttribPointer(testLocPos, 2, pivotGL.FLOAT, false, 0, 0);
      pivotGL.enableVertexAttribArray(testLocPos);
    }
    pivotGL.drawArrays(pivotGL.TRIANGLES, 0, 3);
    fps.tick();
    requestAnimationFrame(drawPivot);
    return;
  }

  // Normal 3D cube rendering
  if (depthTestDisabled) {
    pivotGL.disable(pivotGL.DEPTH_TEST);
  } else {
    pivotGL.enable(pivotGL.DEPTH_TEST);
  }

  const t = (performance.now()-startTime)/1000.0;
  const aspect = pivotCanvas.width/pivotCanvas.height;
  const proj = matPerspective(60*Math.PI/180, aspect, 0.1, 100); // slightly wider FOV
  const view = matTranslate(0,0,zoomLevel);
  const autoRotation = rotationEnabled ? t * 1.5 : 0;
  const rot = matMul(matRotateY(yaw + autoRotation), matRotateX(pitch));
  // FIXED: Reverse order for column-major WebGL matrices (matMul uses row-major convention)
  const mvp = matMul(rot, matMul(view, proj));

  // Render Mt Cook terrain (background) - 3D mesh surface
  if (terrainProgram && terrainVBO && terrainIBO) {
    pivotGL.useProgram(terrainProgram);
    // Apply same rotation as cube for terrain
    pivotGL.uniformMatrix4fv(terrainMVP, false, mvp);

    if (terrainVAO) {
      pivotGL.bindVertexArray(terrainVAO);
    } else {
      // WebGL1 path - setup interleaved attributes
      pivotGL.bindBuffer(pivotGL.ARRAY_BUFFER, terrainVBO);
      pivotGL.bindBuffer(pivotGL.ELEMENT_ARRAY_BUFFER, terrainIBO);
      const stride = 6 * 4;
      const terrainLocPos = pivotGL.getAttribLocation(terrainProgram, 'aPos');
      const terrainLocCol = pivotGL.getAttribLocation(terrainProgram, 'aCol');
      pivotGL.vertexAttribPointer(terrainLocPos, 3, pivotGL.FLOAT, false, stride, 0);
      pivotGL.enableVertexAttribArray(terrainLocPos);
      pivotGL.vertexAttribPointer(terrainLocCol, 3, pivotGL.FLOAT, false, stride, 12);
      pivotGL.enableVertexAttribArray(terrainLocCol);
    }

    // Render as 3D mesh surface (triangles)
    pivotGL.drawElements(pivotGL.TRIANGLES, terrainIndexCount, pivotGL.UNSIGNED_SHORT, 0);
  }

  // Render ground grid plane at y=0
  if (gridProgram && gridVBO) {
    pivotGL.useProgram(gridProgram);
    pivotGL.uniformMatrix4fv(gridMVP, false, mvp);

    if (gridVAO) {
      pivotGL.bindVertexArray(gridVAO);
    } else {
      // WebGL1 path - interleaved attributes
      pivotGL.bindBuffer(pivotGL.ARRAY_BUFFER, gridVBO);
      const gridStride = 6 * 4;
      const gridLocPos = pivotGL.getAttribLocation(gridProgram, 'aPos');
      const gridLocCol = pivotGL.getAttribLocation(gridProgram, 'aCol');
      pivotGL.vertexAttribPointer(gridLocPos, 3, pivotGL.FLOAT, false, gridStride, 0);
      pivotGL.enableVertexAttribArray(gridLocPos);
      pivotGL.vertexAttribPointer(gridLocCol, 3, pivotGL.FLOAT, false, gridStride, 12);
      pivotGL.enableVertexAttribArray(gridLocCol);
    }

    pivotGL.lineWidth(1.0);  // Thin lines for grid
    pivotGL.drawArrays(pivotGL.LINES, 0, gridCount);
  }

  // Render line test patterns (for ANGLE D3D11 curved line issue)
  if (lineTestProgram && lineTestVBO) {
    pivotGL.useProgram(lineTestProgram);
    pivotGL.uniformMatrix4fv(terrainMVP, false, mvp);

    if (lineTestVAO) {
      pivotGL.bindVertexArray(lineTestVAO);
    } else {
      // WebGL1 path
      pivotGL.bindBuffer(pivotGL.ARRAY_BUFFER, lineTestVBO);
      const lineTestStride = 6 * 4;
      const lineTestLocPos = pivotGL.getAttribLocation(lineTestProgram, 'aPos');
      const lineTestLocCol = pivotGL.getAttribLocation(lineTestProgram, 'aCol');
      pivotGL.vertexAttribPointer(lineTestLocPos, 3, pivotGL.FLOAT, false, lineTestStride, 0);
      pivotGL.enableVertexAttribArray(lineTestLocPos);
      pivotGL.vertexAttribPointer(lineTestLocCol, 3, pivotGL.FLOAT, false, lineTestStride, 12);
      pivotGL.enableVertexAttribArray(lineTestLocCol);
    }

    pivotGL.lineWidth(2.0);  // Thicker lines for visibility
    pivotGL.drawArrays(pivotGL.LINES, 0, lineTestCount);
  }

  // Render cube (if visible)
  if (cubeVisible) {
    // Apply cube scale
    const scaleMat = matScale(cubeScale, cubeScale, cubeScale);
    const cubeMVP = matMul(scaleMat, mvp);

    pivotGL.useProgram(program);

  if (vao) {
    // WebGL2: VAO stores all vertex attribute state
    pivotGL.bindVertexArray(vao);
  } else {
    // WebGL1: Manually bind buffers and set up vertex attributes
    pivotGL.bindBuffer(pivotGL.ARRAY_BUFFER, vbo);
    pivotGL.bindBuffer(pivotGL.ELEMENT_ARRAY_BUFFER, ibo);

    const stride = 6 * 4;
    const offsetPos = 0;
    const offsetCol = 3 * 4;

    pivotGL.vertexAttribPointer(locPos, 3, pivotGL.FLOAT, false, stride, offsetPos);
    pivotGL.enableVertexAttribArray(locPos);
    pivotGL.vertexAttribPointer(locCol, 3, pivotGL.FLOAT, false, stride, offsetCol);
    pivotGL.enableVertexAttribArray(locCol);
  }

    pivotGL.uniformMatrix4fv(uMVP,false,cubeMVP);
    pivotGL.uniform1f(uTime, t);

    pivotGL.drawElements(pivotGL.TRIANGLES, 36, pivotGL.UNSIGNED_SHORT, 0);
  } // End of cube rendering

  fps.tick();
  requestAnimationFrame(drawPivot);
}
console.log('Setting up requestAnimationFrame for drawPivot...');
requestAnimationFrame(drawPivot);

/* Context loss simulation (main) */
document.getElementById('simulateLossMain').onclick = _=>{
  if (!pivotGL) return;
  const lose = pivotGL.getExtension('WEBGL_lose_context');
  if (lose) { addStatus('Simulating context loss (main)â€¦','warn'); lose.loseContext(); setTimeout(()=>{ lose.restoreContext(); addStatus('Main context restored.'); }, 1500); }
  else addStatus('WEBGL_lose_context not available.','warn');
};
pivotCanvas.addEventListener('webglcontextlost',(ev)=>{ev.preventDefault(); addStatus('Main context lost','warn');});
pivotCanvas.addEventListener('webglcontextrestored',()=>{ addStatus('Main context restored','ok'); requestAnimationFrame(drawPivot); });

/* -------------------- OffscreenCanvas Worker demo (patched) -------------------- */
const workerCanvas = document.getElementById('workerCanvas');
let worker = null, workerRunning = false;
let workerBlobURL = null;

function makeWorkerBlobURL() {
  const workerSrc = `
    let gl=null, program=null, uTime=null, buf=null, running=false, start=0;

    function compile(gl,t,s){const sh=gl.createShader(t);gl.shaderSource(sh,s);gl.compileShader(sh);
      if(!gl.getShaderParameter(sh,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(sh)); return sh;}
    function link(gl,vs,fs){const p=gl.createProgram();gl.attachShader(p,vs);gl.attachShader(p,fs);gl.linkProgram(p);
      if(!gl.getProgramParameter(p,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p)); return p;}

    const vs300=\`#version 300 es
      uniform highp float uTime;
      layout(location=0) in vec2 pos;
      void main(){
        float k = 0.3 + 0.2 * sin(uTime * 1.7);
        gl_Position = vec4(pos * vec2(1.0, k), 0.0, 1.0);
      }\`;
    const fs300=\`#version 300 es
      precision highp float;
      uniform highp float uTime;
      out vec4 outColor;
      void main(){
        outColor = vec4(
          0.3 + 0.7 * abs(sin(uTime * 0.9)),
          0.6,
          0.4 + 0.6 * abs(cos(uTime * 1.1)),
          1.0
        );
      }\`;

    function init(off, scale) {
      gl = off.getContext('webgl2', {alpha:false,antialias:true,preserveDrawingBuffer:false,powerPreference:'high-performance'});
      if (!gl) { postMessage({type:'status', text:'Worker failed to create WebGL2', cls:'bad'}); return; }

      const vs=compile(gl,gl.VERTEX_SHADER,vs300), fs=compile(gl,gl.FRAGMENT_SHADER,fs300);
      program=link(gl,vs,fs); gl.useProgram(program);
      uTime = gl.getUniformLocation(program,'uTime');

      buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      const tri = new Float32Array([-0.8,-0.8, 0.8,-0.8, 0.0,0.8]);
      gl.bufferData(gl.ARRAY_BUFFER, tri, gl.STATIC_DRAW);
      gl.vertexAttribPointer(0,2,gl.FLOAT,false,0,0); gl.enableVertexAttribArray(0);

      start = performance.now(); running=true;
      postMessage({type:'status', text:'Worker WebGL ready', cls:'ok'});
      self.requestAnimationFrame(frame);
    }

    function resize(w,h, scale) {
      const dw = Math.max(1, Math.floor(w * (scale||1)));
      const dh = Math.max(1, Math.floor(h * (scale||1)));
      gl.canvas.width = dw;
      gl.canvas.height = dh;
      gl.viewport(0,0,dw,dh);
    }

    function frame(t){
      if(!running) return;
      const time = (t-start)/1000.0;
      gl.clearColor(0.05,0.08,0.14,1); gl.clear(gl.COLOR_BUFFER_BIT);
      gl.uniform1f(uTime, time);
      gl.drawArrays(gl.TRIANGLES, 0, 3);
      self.requestAnimationFrame(frame);
    }

    self.onmessage = ev=>{
      const m = ev.data;
      if (m.cmd==='init'){ init(m.canvas, m.scale); resize(m.w, m.h, m.scale); }
      else if (m.cmd==='resize'){ resize(m.w, m.h, m.scale); }
      else if (m.cmd==='stop'){ running=false; }
      else if (m.cmd==='lose'){
        const ext = gl.getExtension('WEBGL_lose_context');
        if (ext){ ext.loseContext(); setTimeout(()=>ext.restoreContext(),1500); }
      }
    };
  `;
  const blob = new Blob([workerSrc], {type:'application/javascript'});
  return URL.createObjectURL(blob);
}

function startWorker() {
  if (workerRunning) return;

  if (!('transferControlToOffscreen' in HTMLCanvasElement.prototype)) {
    addStatus('OffscreenCanvas not supported/allowed on this device. (Policy or build).', 'warn');
    return;
  }

  // Show worker section
  document.getElementById('workerSection').classList.add('visible');
  document.getElementById('canvases').classList.remove('worker-hidden');
  document.getElementById('canvases').classList.add('worker-visible');

  const w = Math.max(1, workerCanvas.clientWidth || 640);
  const h = Math.max(1, workerCanvas.clientHeight || 360);
  const scale = window.devicePixelRatio || 1;

  const off = workerCanvas.transferControlToOffscreen();

  if (!workerBlobURL) workerBlobURL = makeWorkerBlobURL();
  worker = new Worker(workerBlobURL);
  worker.onmessage = (ev)=>{
    const {type,text,cls} = ev.data || {};
    if (type==='status') addStatus(text, cls||'ok');
  };

  worker.postMessage({cmd:'init', canvas:off, w, h, scale}, [off]);
  workerRunning = true;
  document.getElementById('toggleWorker').textContent = 'Stop worker render';
  addStatus('Worker started.');
}

function stopWorker() {
  if (!workerRunning) return;
  worker.postMessage({cmd:'stop'});
  worker.terminate();
  worker = null; workerRunning = false;
  document.getElementById('toggleWorker').textContent = 'Start worker render';

  // Hide worker section
  document.getElementById('workerSection').classList.remove('visible');
  document.getElementById('canvases').classList.remove('worker-visible');
  document.getElementById('canvases').classList.add('worker-hidden');

  addStatus('Worker stopped.');
}

function resizeWorker(){
  if (!workerRunning) return;
  const w = Math.max(1, workerCanvas.clientWidth || 640);
  const h = Math.max(1, workerCanvas.clientHeight || 360);
  const scale = window.devicePixelRatio || 1;
  worker.postMessage({cmd:'resize', w, h, scale});
}

window.addEventListener('resize', resizeWorker);
document.getElementById('toggleWorker').onclick = ()=> workerRunning ? stopWorker() : startWorker();
document.getElementById('simulateLossWorker').onclick = ()=>{
  if (!workerRunning) { addStatus('Worker not running.','warn'); return; }
  addStatus('Simulating context loss (worker)â€¦','warn');
  worker.postMessage({cmd:'lose'});
};

/* -------------------- Diagnostics pack (JSON) -------------------- */
document.getElementById('downloadDiag').onclick = ()=>{
  const data = {
    when: new Date().toISOString(),
    userAgent: navigator.userAgent,
    uaData: (navigator.userAgentData && navigator.userAgentData.toJSON) ? navigator.userAgentData.toJSON() : null,
    memory: performance.memory ? {
      jsHeapSizeLimit: performance.memory.jsHeapSizeLimit,
      totalJSHeapSize: performance.memory.totalJSHeapSize,
      usedJSHeapSize: performance.memory.usedJSHeapSize
    } : null,
    renderer: ri,
    fps: fps.snapshot()
  };
  const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'angle-diagnostics.json';
  a.click();
  URL.revokeObjectURL(a.href);
  addStatus('Diagnostics JSON downloaded.');
};
</script>
</body>
</html>
